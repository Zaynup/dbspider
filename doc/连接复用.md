# 连接复用

## 1. 为什么要连接复用？

+ 对于短连接来说，每次发起 rpc 调用就创建一条连接，由于没有竞争实现起来比较容易，但开销太大。所以通过rpc连接复用来支持更高的并发。

## 2. 连接复用的问题？

+ 连接复用的问题在于，在一条连接上可以有多个并发的调用请求，由于服务器也是并发处理这些请求的，所以导致了服务器返回的响应顺序与请求顺序不一致。

## 3. 解决办法

+ 为了识别请求，给每个连接每个请求加上一个唯一的序列号，本框架的做法是在协议头加上序列号字段，具体结构如下：

    ```C++
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    |  BYTE  |        |        |        |        |        |        |        |        |        |        |             ........                                                           |
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    |  magic | version|  type  |          sequence id              |          content length           |             content byte[]                                                     |
    +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
    ```

    第四个字段就是一个32位的序列号，用来识别请求顺序。

+ 解决了请求标识的问题，剩下的问题就是**如何收集并发的调用请求，并按串行的顺序发送给服务提供方，以及如何将收到的调用结果转发给等待的调用者**，即连接的多路复用与多路分解。

### 3.1 多路复用

![Alt text](imags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

+ 

![Alt text](imags/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)